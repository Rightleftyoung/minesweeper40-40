<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }

        .game-container {
            background-color: #c0c0c0;
            padding: 20px;
            border: 3px outset #c0c0c0;
            border-radius: 5px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #c0c0c0;
            border: 2px inset #c0c0c0;
        }

        .mine-counter, .timer, .score {
            background-color: #000;
            color: #f00;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            padding: 5px 10px;
            border: 2px inset #c0c0c0;
            min-width: 60px;
            text-align: center;
        }

        .mine-counter.showing-mines {
            background-color: #4CAF50;
            color: #fff;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            background-color: #c0c0c0;
            border: 2px outset #c0c0c0;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn:hover {
            background-color: #d0d0d0;
        }

        .btn:active {
            border: 2px inset #c0c0c0;
        }

        .btn:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
        }

        .btn.active-mode {
            background-color: #4CAF50;
            color: #fff;
            border: 2px inset #2e7d32;
        }

        .game-board {
            display: grid;
            gap: 1px;
            background-color: #c0c0c0;
            border: none;
            padding: 0;
            overflow: auto;
            max-height: 70vh;
        }

        .cell {
            width: 30px;
            height: 30px;
            background-color: #c0c0c0;
            border: 1px solid #808080;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .cell:hover {
            background-color: #d0d0d0;
        }

        .cell.revealed {
            background-color: #87CEEB;
            border: 1px solid #808080;
            cursor: default;
        }

        .cell.revealed:hover {
            background-color: #87CEEB;
        }

        .cell.flagged {
            background-color: #87CEEB;
            color: #f00;
        }

        .cell.mine {
            background-color: #f00;
            color: #fff;
        }

        .cell.mine-lost {
            background-color: #0066ff;
            color: #fff;
        }

        .cell.mine-flagged {
            background-color: #0f0;
            color: #000;
        }

        .cell.number-0 { color: #808080; }
        .cell.number-1 { color: #0000ff; }
        .cell.number-2 { color: #008000; }
        .cell.number-3 { color: #ff0000; }
        .cell.number-4 { color: #000080; }
        .cell.number-5 { color: #800000; }
        .cell.number-6 { color: #008080; }
        .cell.number-7 { color: #000000; }
        .cell.number-8 { color: #808080; }

        .game-status {
            margin-top: 15px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }

        .win { color: #008000; }
        .lose { color: #ff0000; }

        /* Simple modal for minigame */
        /* Disable selection on mobile */
        html, body, .game-container, .btn, .cell {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 420px;
            text-align: center;
        }
        .target-area {
            position: relative;
            margin: 12px auto 0;
            width: 280px;
            height: 180px;
            background: #222;
            border-radius: 6px;
            overflow: hidden;
            touch-action: none;
        }
        .target {
            position: absolute;
            width: 36px;
            height: 36px;
            line-height: 36px;
            text-align: center;
            border-radius: 50%;
            background: #ff4757;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
        }
        .size-editor-group {
            display: grid;
            gap: 6px;
            margin-bottom: 12px;
            text-align: left;
        }
        .size-editor-group label {
            font-weight: bold;
        }
        .size-editor-group input[type="number"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #808080;
            border-radius: 4px;
            font-size: 14px;
        }
        .size-editor-group input[type="range"] {
            width: 100%;
        }
        .size-editor-summary {
            margin-top: 8px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Minesweeper</h1>
    
    <div class="game-container">
        <div class="game-header">
            <div class="mine-counter" id="mineCounter">325</div>
            <div class="score" id="score">00000</div>
            <div class="score" id="totalScore">00000</div>
            <div class="controls">
                <button class="btn" id="newGameBtn">New Game</button>
                <select class="btn" id="difficultySelect" style="padding: 8px 12px;">
                    <option value="easy">Easy (12.5%)</option>
                    <option value="medium" selected>Medium (20.3%)</option>
                    <option value="hard">Hard (28.1%)</option>
                    <option value="expert">Expert (31.3%)</option>
                    <option value="revengeance">Revengeance (40.6%-50%)</option>
                    <option value="custom">Custom</option>
                </select>
                <button class="btn" id="bombBtn">Bomb (5x5)</button>
                <button class="btn" id="hintBtn">Hint</button>
                <button class="btn" id="revealMineBtn">Reveal Mine</button>
                <button class="btn" id="mineDetectorBtn">Mine Detector (300)</button>
                <button class="btn" id="buyFlagBtn">Buy Flag (100)</button>
                <button class="btn" id="miniGameBtn">Mini Game</button>
                <button class="btn" id="powersToggleBtn">Powers: On</button>
                <button class="btn" id="sizeEditorBtn">Size Editor</button>
                <button class="btn" id="checkpointBtn">Checkpoint (1000)</button>
                <button class="btn" id="showMinesBtn">Show Mines Left (100)</button>
                <button class="btn" id="interactionRevealBtn">Reveal Mode</button>
                <button class="btn" id="interactionFlagBtn">Flag Mode</button>
            </div>
            <div class="timer" id="timer">000</div>
        </div>
        
        <div class="game-board" id="gameBoard"></div>
        
        <div class="game-status" id="gameStatus"></div>
    </div>

    <!-- Minigame Modal -->
    <div class="modal-overlay" id="miniGameModal">
        <div class="modal">
            <h3>Mini Games</h3>
            <p>
                <select class="btn" id="miniGameSelect" style="padding:8px 12px;">
                    <option value="tap">Tap The Mine</option>
                    <option value="react">Reaction Timer</option>
                    <option value="simon">Simon Sequence</option>
                    <option value="frenzy">Target Frenzy</option>
                    <option value="numbers">Number Tap</option>
                    <option value="moles">Whack-a-Mine</option>
                    <option value="math">Math Sprint</option>
                    <option value="hold">Hold Challenge</option>
                    <option value="coin">Coin Flip</option>
                </select>
            </p>
            <div id="miniGameDesc">Tap the moving target 10 times in 15 seconds to win 5,000 points.</div>
            <div class="target-area" id="targetArea" style="margin-top:10px;">
                <div class="target" id="target">ðŸ’£</div>
                <!-- Reaction UI -->
                <div id="reactionLight" style="display:none;position:absolute;inset:0;align-items:center;justify-content:center;color:#fff;font-size:22px;">
                    <div id="reactionText">Wait for green...</div>
                </div>
                <!-- Simon UI -->
                <div id="simonGrid" style="display:none;position:absolute;inset:8px;display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                    <div class="simon" data-idx="0" style="background:#e74c3c;border-radius:6px;"></div>
                    <div class="simon" data-idx="1" style="background:#27ae60;border-radius:6px;"></div>
                    <div class="simon" data-idx="2" style="background:#2980b9;border-radius:6px;"></div>
                    <div class="simon" data-idx="3" style="background:#f1c40f;border-radius:6px;"></div>
                </div>
                <!-- Math choices -->
                <div id="mathWrap" style="display:none;position:absolute;inset:8px;display:flex;flex-direction:column;gap:8px;color:#fff;">
                    <div id="mathQuestion" style="text-align:center;font-size:18px;"></div>
                    <div style="display:flex;gap:8px;justify-content:center;">
                        <button class="btn" id="mathA"></button>
                        <button class="btn" id="mathB"></button>
                        <button class="btn" id="mathC"></button>
                    </div>
                </div>
                <!-- Hold bar -->
                <div id="holdBarWrap" style="display:none;position:absolute;left:12px;right:12px;bottom:12px;height:16px;background:#444;border-radius:8px;overflow:hidden;">
                    <div id="holdBar" style="height:100%;width:0%;background:#2ecc71;"></div>
                </div>
                <!-- Coin flip UI -->
                <div id="coinWrap" style="display:none;position:absolute;inset:8px;display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center;">
                    <div id="coinStatus" style="color:#fff;font-size:18px;">Pick Heads or Tails</div>
                    <div>
                        <button class="btn" id="headsBtn">Heads</button>
                        <button class="btn" id="tailsBtn">Tails</button>
                    </div>
                </div>
            </div>
            <p id="miniGameInfo" style="margin-top:8px;">Hits: 0/10 â€¢ Time: 15s</p>
            <button class="btn" id="startMiniGameBtn">Start</button>
            <button class="btn" id="closeMiniGameBtn">Close</button>
        </div>
    </div>

    <!-- Size Editor Modal -->
    <div class="modal-overlay" id="sizeEditorModal">
        <div class="modal">
            <h3>Board Size Editor</h3>
            <p style="margin-bottom:12px;">Adjust rows, columns, and mine density to scale the board.</p>
            <div class="size-editor-group">
                <label for="rowsSlider">Rows</label>
                <input id="rowsSlider" type="range" min="5" max="100" value="40">
                <input id="rowsInput" type="number" min="5" max="100" value="40">
            </div>
            <div class="size-editor-group">
                <label for="colsSlider">Columns</label>
                <input id="colsSlider" type="range" min="5" max="100" value="40">
                <input id="colsInput" type="number" min="5" max="100" value="40">
            </div>
            <div class="size-editor-group">
                <label for="densityInput">Mine Density</label>
                <input id="densityInput" type="range" min="5" max="50" step="0.1" value="20">
                <span id="densityDisplay">20%</span>
            </div>
            <div class="size-editor-summary" id="sizeEditorSummary">
                40 Ã— 40 â€¢ 1,600 cells â€¢ 325 mines â€¢ 5 bombs
            </div>
            <div style="display:flex;gap:10px;justify-content:center;margin-top:14px;">
                <button class="btn" id="sizeApplyBtn">Apply</button>
                <button class="btn" id="sizeCancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        class Minesweeper {
            constructor(rows = 16, cols = 16, mines = 40) {
                this.rows = rows;
                this.cols = cols;
                this.mines = mines;
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                this.gameOver = false;
                this.gameWon = false;
                this.startTime = null;
                this.timerInterval = null;
                this.holdTimer = null;
                this.holdThreshold = 500; // milliseconds to hold for flag
                this.bombsUsed = 0; // Track number of bombs used (will scale with board size)
                this.mineRevealed = false; // Track if mine has been revealed
                this.bombTargeting = false; // Track if bomb targeting mode is active
                this.mineDetectorActive = false; // Track if mine detector is active
                this.hintsUsed = 0; // Track number of hints used (max 5)
                this.score = 0; // Track score (5 points per revealed safe tile)
                this.totalScore = Number(localStorage.getItem('ms_totalScore') || '0');
                this.lostMineRow = null; // Track which mine caused the loss
                this.lostMineCol = null;
                this.powersDisabledMode = false; // Powers disabled => double points
                this.baseArea = 40 * 40;
                this.baseHintCount = 5;
                this.baseCosts = {
                    mineDetector: 300,
                    buyFlag: 100,
                    revealMine: 500,
                    showMines: 100
                };
                this.priceMultiplier = 1;
                this.mineDetectorCost = this.baseCosts.mineDetector;
                this.buyFlagCost = this.baseCosts.buyFlag;
                this.revealMineCost = this.baseCosts.revealMine;
                this.showMinesCost = this.baseCosts.showMines;
                this.checkpointCost = 1000;
                this.checkpointState = null;
                this.showMinesActive = false;
                this.showMinesTimeout = null;
                this.difficultyProfiles = {
                    easy: { label: 'Easy', density: 200 / this.baseArea },
                    medium: { label: 'Medium', density: 325 / this.baseArea },
                    hard: { label: 'Hard', density: 450 / this.baseArea },
                    expert: { label: 'Expert', density: 500 / this.baseArea },
                    revengeance: { label: 'Revengeance', densityRange: [650 / this.baseArea, 800 / this.baseArea] }
                };
                this.updateDifficultyOptionLabels();

                const difficultySelect = document.getElementById('difficultySelect');
                const initialDifficulty = difficultySelect ? difficultySelect.value : 'medium';
                this.difficultyKey = this.difficultyProfiles[initialDifficulty] ? initialDifficulty : 'custom';
                this.mineDensityRange = null;
                const fallbackDensity = (this.rows && this.cols) ? (this.mines / (this.rows * this.cols)) : 0.2;
                if (this.difficultyKey === 'custom') {
                    this.mineDensity = fallbackDensity;
                } else {
                    const profile = this.difficultyProfiles[this.difficultyKey];
                    if (profile?.densityRange) {
                        this.mineDensityRange = profile.densityRange;
                        this.mineDensity = profile.densityRange[0];
                    } else {
                        this.mineDensity = profile?.density ?? fallbackDensity;
                    }
                }
                this.mineDensity = this.resolveMineDensity();
                this.mines = Math.max(1, Math.round(this.mineDensity * this.rows * this.cols));
                this.availableFlags = this.mines;
                this.maxBombs = this.calculateMaxBombs();
                this.maxHints = this.calculateMaxHints();
                this.updateCostsForDimensions(this.rows, this.cols);
                this.interactionMode = 'auto';

                this.initializeBoard();
                this.setupEventListeners();
                this.render();
                this.syncSizeEditorDefaults();
                this.updateCostLabels();
                this.updateHintButton();
                this.updateCheckpointButton();

                // Mobile copy/select/callout prevention
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    const block = (e) => e.preventDefault();
                    ['copy','cut','paste','selectstart','contextmenu','dragstart'].forEach(ev => {
                        document.addEventListener(ev, block, { passive: false });
                    });
                }
            }

            initializeBoard() {
                // Initialize empty board
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.revealed = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.flagged = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                
                // Place mines randomly
                let minesPlaced = 0;
                while (minesPlaced < this.mines) {
                    const row = Math.floor(Math.random() * this.rows);
                    const col = Math.floor(Math.random() * this.cols);
                    if (this.board[row][col] !== -1) {
                        this.board[row][col] = -1; // -1 represents a mine
                        minesPlaced++;
                    }
                }
                
                // Calculate numbers for each cell
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.board[row][col] !== -1) {
                            this.board[row][col] = this.countAdjacentMines(row, col);
                        }
                    }
                }
            }

            countAdjacentMines(row, col) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < this.rows && 
                            newCol >= 0 && newCol < this.cols && 
                            this.board[newRow][newCol] === -1) {
                            count++;
                        }
                    }
                }
                return count;
            }

            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('difficultySelect').addEventListener('change', () => this.changeDifficulty());
                document.getElementById('bombBtn').addEventListener('click', () => this.bombFunction());
                document.getElementById('hintBtn').addEventListener('click', () => this.hintFunction());
                document.getElementById('revealMineBtn').addEventListener('click', () => this.revealMineFunction());
                document.getElementById('mineDetectorBtn').addEventListener('click', () => this.mineDetectorFunction());
                document.getElementById('buyFlagBtn').addEventListener('click', () => this.buyFlagFunction());
                document.getElementById('miniGameBtn').addEventListener('click', () => this.openMiniGame());
                document.getElementById('powersToggleBtn').addEventListener('click', () => this.togglePowers());
                document.getElementById('sizeEditorBtn').addEventListener('click', () => this.openSizeEditor());
                document.getElementById('checkpointBtn').addEventListener('click', () => this.checkpointFunction());
                document.getElementById('showMinesBtn').addEventListener('click', () => this.showMinesLeftFunction());
                const revealModeBtn = document.getElementById('interactionRevealBtn');
                const flagModeBtn = document.getElementById('interactionFlagBtn');
                if (revealModeBtn) revealModeBtn.addEventListener('click', () => this.toggleInteractionMode('reveal'));
                if (flagModeBtn) flagModeBtn.addEventListener('click', () => this.toggleInteractionMode('flag'));
                document.getElementById('sizeApplyBtn').addEventListener('click', () => this.applySizeEditor());
                document.getElementById('sizeCancelBtn').addEventListener('click', () => this.closeSizeEditor());
                const sizeInputs = ['rowsSlider','colsSlider','rowsInput','colsInput','densityInput'];
                sizeInputs.forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.addEventListener('input', () => this.handleSizeEditorInput(id));
                    el.addEventListener('change', () => this.handleSizeEditorInput(id));
                });
            }

            render() {
                const gameBoard = document.getElementById('gameBoard');
                gameBoard.innerHTML = '';
                gameBoard.style.gridTemplateColumns = `repeat(${this.cols}, 30px)`;
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        if (this.revealed[row][col]) {
                            cell.classList.add('revealed');
                            if (this.board[row][col] === -1) {
                                if (row === this.lostMineRow && col === this.lostMineCol) {
                                    cell.classList.add('mine-lost');
                                } else {
                                    cell.classList.add('mine');
                                }
                                cell.textContent = 'ðŸ’£';
                            } else {
                                cell.classList.add(`number-${this.board[row][col]}`);
                                cell.textContent = this.board[row][col];
                            }
                        } else if (this.flagged[row][col]) {
                            cell.classList.add('flagged');
                            cell.textContent = 'ðŸš©';
                        }
                        
                        // Mouse events
                        cell.addEventListener('mousedown', (e) => this.handleMouseDown(e, row, col));
                        cell.addEventListener('mouseup', (e) => this.handleMouseUp(e, row, col));
                        cell.addEventListener('mouseleave', () => this.handleMouseLeave(row, col));
                        cell.addEventListener('contextmenu', (e) => e.preventDefault());
                        
                        // Touch events (mobile): tap to reveal, long-press to flag
                        let touchStartTime = 0;
                        let touchMoved = false;
                        cell.addEventListener('touchstart', (e) => {
                            if (this.gameOver || this.gameWon) return;
                            touchMoved = false;
                            touchStartTime = performance.now();
                            if (this.interactionMode === 'auto') {
                                this.holdTimer = setTimeout(() => {
                                    this.flagCell(row, col);
                                }, this.holdThreshold);
                            } else {
                                this.holdTimer = null;
                            }
                        }, { passive: true });
                        cell.addEventListener('touchmove', () => {
                            touchMoved = true;
                            if (this.holdTimer) { clearTimeout(this.holdTimer); this.holdTimer = null; }
                        }, { passive: true });
                        cell.addEventListener('touchend', (e) => {
                            if (this.holdTimer) { clearTimeout(this.holdTimer); this.holdTimer = null; }
                            const duration = performance.now() - touchStartTime;
                            if (touchMoved) return;
                            if (this.interactionMode === 'flag') {
                                this.flagCell(row, col);
                                return;
                            }
                            // If short tap, act like left-click
                            if (duration < this.holdThreshold || this.interactionMode !== 'auto') {
                                if (this.bombTargeting) {
                                    this.dropBomb(row, col);
                                } else if (this.mineDetectorActive) {
                                    this.useMineDetector(row, col);
                                } else {
                                    if (this.flagged[row][col]) return;
                                    if (this.revealed[row][col]) {
                                        this.revealAdjacentCells(row, col);
                                    } else {
                                        this.revealCell(row, col);
                                    }
                                }
                            }
                        });
                        
                        gameBoard.appendChild(cell);
                    }
                }
                
                this.updateMineCounter();
                this.updateScore();
                this.updateTotalScore();
                this.updateGameStatus();
                this.updateBombUi();
                this.refreshPowerButtons();
                this.updateCostLabels();
            }

            handleMouseDown(e, row, col) {
                if (this.gameOver || this.gameWon) return;
                
                if (e.button === 0 && this.interactionMode === 'auto') { // Left click
                    this.holdTimer = setTimeout(() => {
                        this.flagCell(row, col);
                    }, this.holdThreshold);
                }
            }

            handleMouseUp(e, row, col) {
                if (this.gameOver || this.gameWon) return;
                
                if (this.holdTimer) {
                    clearTimeout(this.holdTimer);
                    this.holdTimer = null;
                }
                
                if (e.button === 0) { // Left click
                    if (this.bombTargeting) {
                        this.dropBomb(row, col);
                    } else if (this.mineDetectorActive) {
                        this.useMineDetector(row, col);
                    } else if (this.interactionMode === 'flag') {
                        this.flagCell(row, col);
                    } else {
                        if (this.flagged[row][col]) return;
                        if (this.revealed[row][col]) {
                            this.revealAdjacentCells(row, col);
                        } else {
                            this.revealCell(row, col);
                        }
                    }
                }
            }

            handleMouseLeave(row, col) {
                if (this.holdTimer) {
                    clearTimeout(this.holdTimer);
                    this.holdTimer = null;
                }
            }

            revealCell(row, col) {
                if (this.revealed[row][col] || this.flagged[row][col] || this.gameOver || this.gameWon) {
                    return;
                }
                
                if (!this.startTime) {
                    this.startTime = Date.now();
                    this.startTimer();
                }
                
                this.revealed[row][col] = true;
                if (this.board[row][col] !== -1) {
                    this.addScore(5);
                }
                
                if (this.board[row][col] === -1) {
                    this.gameOver = true;
                    this.interactionMode = 'auto';
                    this.clearShowMinesIndicator();
                    this.lostMineRow = row;
                    this.lostMineCol = col;
                    this.revealAllMines();
                    this.stopTimer();
                } else if (this.board[row][col] === 0) {
                    // Auto-reveal adjacent cells for empty cells
                    this.revealAdjacentCells(row, col);
                }
                
                this.checkWinCondition();
                this.render();
            }

            revealAdjacentCells(row, col) {
                if (!this.revealed[row][col]) return;
                
                const adjacentFlags = this.countAdjacentFlags(row, col);
                const adjacentMines = this.board[row][col];
                
                // Only reveal if flag count matches the number on the tile
                if (adjacentFlags === adjacentMines) {
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const newRow = row + i;
                            const newCol = col + j;
                            if (newRow >= 0 && newRow < this.rows && 
                                newCol >= 0 && newCol < this.cols && 
                                !this.revealed[newRow][newCol] && 
                                !this.flagged[newRow][newCol]) {
                                this.revealCell(newRow, newCol);
                            }
                        }
                    }
                }
            }

            countAdjacentFlags(row, col) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < this.rows && 
                            newCol >= 0 && newCol < this.cols && 
                            this.flagged[newRow][newCol]) {
                            count++;
                        }
                    }
                }
                return count;
            }

            flagCell(row, col) {
                if (this.revealed[row][col] || this.gameOver || this.gameWon) {
                    return;
                }
                
                if (!this.flagged[row][col] && this.availableFlags <= 0) {
                    return; // No flags available
                }
                
                if (!this.flagged[row][col]) {
                    this.availableFlags--;
                } else {
                    this.availableFlags++;
                }
                
                this.flagged[row][col] = !this.flagged[row][col];
                this.render();
            }

            changeDifficulty() {
                const selectedValue = document.getElementById('difficultySelect').value;
                if (selectedValue === 'custom') {
                    this.difficultyKey = 'custom';
                    this.mineDensityRange = null;
                    this.syncSizeEditorDefaults();
                    return;
                }
                const profile = this.difficultyProfiles[selectedValue];
                if (!profile) {
                    return;
                }
                this.difficultyKey = selectedValue;
                this.mineDensityRange = profile.densityRange || null;
                if (profile.density != null) {
                    this.mineDensity = profile.density;
                }
                this.newGame();
            }

            bombFunction() {
                if (this.gameOver || this.gameWon) return;
                if (this.maxBombs === 0 || this.bombsUsed >= this.maxBombs) {
                    this.updateBombUi();
                    return;
                }
                
                this.bombTargeting = !this.bombTargeting;
                this.updateBombUi();
            }

            dropBomb(centerRow, centerCol) {
                if (this.gameOver || this.gameWon || this.maxBombs === 0 || this.bombsUsed >= this.maxBombs || !this.bombTargeting) return;
                
                // Reveal 5x5 area around the center
                for (let row = Math.max(0, centerRow - 2); row <= Math.min(this.rows - 1, centerRow + 2); row++) {
                    for (let col = Math.max(0, centerCol - 2); col <= Math.min(this.cols - 1, centerCol + 2); col++) {
                        if (!this.revealed[row][col]) {
                            if (this.board[row][col] === -1) {
                                // Flag mines in the 5x5 area
                                this.flagged[row][col] = true;
                            } else {
                                // Reveal non-mine cells
                                this.revealed[row][col] = true;
                                this.addScore(5);
                            }
                        }
                    }
                }
                
                // Increment bomb usage and exit targeting mode
                this.bombsUsed++;
                this.bombTargeting = false;
                
                this.checkWinCondition();
                this.updateBombUi();
                this.render();
            }

            hintFunction() {
                if (this.gameOver || this.gameWon) return;
                if (this.powersDisabledMode) return;
                if (this.maxHints === 0 || this.hintsUsed >= this.maxHints) return;
                
                // Find a revealed cell with a number that has unrevealed adjacent cells
                const hintCandidates = [];
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.revealed[row][col] && this.board[row][col] > 0) {
                            // Count unrevealed adjacent cells
                            let unrevealedAdjacent = 0;
                            for (let i = -1; i <= 1; i++) {
                                for (let j = -1; j <= 1; j++) {
                                    const newRow = row + i;
                                    const newCol = col + j;
                                    if (newRow >= 0 && newRow < this.rows && 
                                        newCol >= 0 && newCol < this.cols && 
                                        !this.revealed[newRow][newCol] && 
                                        !this.flagged[newRow][newCol]) {
                                        unrevealedAdjacent++;
                                    }
                                }
                            }
                            
                            // If this cell has unrevealed adjacent cells, it's a good hint candidate
                            if (unrevealedAdjacent > 0) {
                                hintCandidates.push({row, col, unrevealedAdjacent});
                            }
                        }
                    }
                }
                
                if (hintCandidates.length === 0) return;
                
                // Pick a random hint candidate
                const hintCell = hintCandidates[Math.floor(Math.random() * hintCandidates.length)];
                const row = hintCell.row;
                const col = hintCell.col;
                
                // Reveal all unrevealed adjacent cells around this number
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < this.rows && 
                            newCol >= 0 && newCol < this.cols && 
                            !this.revealed[newRow][newCol] && 
                            !this.flagged[newRow][newCol]) {
                            
                            if (this.board[newRow][newCol] === -1) {
                                // Flag if it's a mine
                                this.flagged[newRow][newCol] = true;
                                this.availableFlags--;
                            } else {
                                // Reveal if it's not a mine
                                this.revealed[newRow][newCol] = true;
                                this.addScore(5);
                            }
                        }
                    }
                }
                
                // Increment hint usage
                this.hintsUsed++;
                this.updateHintButton();
                
                this.checkWinCondition();
                this.render();
            }

            mineDetectorFunction() {
                if (this.gameOver || this.gameWon) return;
                if (this.powersDisabledMode) return;
                const btn = document.getElementById('mineDetectorBtn');
                if (!btn) return;
                if (this.mineDetectorActive) {
                    // Cancel mine detector mode
                    this.mineDetectorActive = false;
                    this.setMineDetectorIdleLabel();
                } else {
                    // Enter mine detector mode
                    this.mineDetectorActive = true;
                    btn.textContent = 'Click to Detect';
                    btn.style.backgroundColor = '#4CAF50';
                }
            }

            useMineDetector(row, col) {
                if (this.gameOver || this.gameWon || !this.mineDetectorActive) return;
                
                // Check if player has enough points
                const cost = this.mineDetectorCost;
                if (this.totalScore < cost) {
                    // Not enough points, cancel detector mode
                    this.mineDetectorActive = false;
                    this.setMineDetectorIdleLabel();
                    return;
                }
                
                // Don't work on already revealed or flagged tiles
                if (this.revealed[row][col] || this.flagged[row][col]) {
                    return;
                }
                
                // Deduct points
                this.totalScore -= cost;
                localStorage.setItem('ms_totalScore', String(this.totalScore));
                this.updateTotalScore();
                
                // Check the tile
                if (this.board[row][col] === -1) {
                    // It's a mine - flag it
                    this.flagged[row][col] = true;
                    this.availableFlags--;
                } else {
                    // It's safe - reveal it
                    this.revealed[row][col] = true;
                    this.addScore(5);
                }
                
                // Exit detector mode after use
                this.mineDetectorActive = false;
                this.setMineDetectorIdleLabel();
                
                this.checkWinCondition();
                this.render();
            }

            revealMineFunction() {
                if (this.gameOver || this.gameWon) return;
                if (this.powersDisabledMode) return;
                
                // Find mines that are adjacent to revealed tiles
                const adjacentMines = [];
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.board[row][col] === -1 && !this.revealed[row][col] && !this.flagged[row][col]) {
                            // Check if this mine is adjacent to any revealed tile
                            for (let i = -1; i <= 1; i++) {
                                for (let j = -1; j <= 1; j++) {
                                    const newRow = row + i;
                                    const newCol = col + j;
                                    if (newRow >= 0 && newRow < this.rows && 
                                        newCol >= 0 && newCol < this.cols && 
                                        this.revealed[newRow][newCol]) {
                                        adjacentMines.push({row, col});
                                        break;
                                    }
                                }
                                if (adjacentMines.some(mine => mine.row === row && mine.col === col)) break;
                            }
                        }
                    }
                }
                
                if (adjacentMines.length === 0) return;
                
                // Pick a random mine adjacent to revealed tiles
                const randomMine = adjacentMines[Math.floor(Math.random() * adjacentMines.length)];
                this.flagged[randomMine.row][randomMine.col] = true;
                this.availableFlags--;
                
                // Deduct points from total score
                const cost = this.revealMineCost;
                this.totalScore = Math.max(0, this.totalScore - cost);
                localStorage.setItem('ms_totalScore', String(this.totalScore));
                this.updateTotalScore();
                
                this.checkWinCondition();
                this.render();
            }

            buyFlagFunction() {
                if (this.gameOver || this.gameWon) return;
                if (this.powersDisabledMode) return;
                
                // Check if player has enough points
                const cost = this.buyFlagCost;
                if (this.totalScore >= cost) {
                    this.totalScore -= cost;
                    this.availableFlags++;
                    localStorage.setItem('ms_totalScore', String(this.totalScore));
                    this.updateTotalScore();
                    this.updateMineCounter();
                }
            }

            revealAllMines() {
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (!this.revealed[row][col]) {
                            this.revealed[row][col] = true;
                        }
                    }
                }
            }

            checkWinCondition() {
                let flaggedMines = 0;
                let coveredTiles = 0;
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.flagged[row][col] && this.board[row][col] === -1) {
                            flaggedMines++;
                        }
                        if (!this.revealed[row][col] && !this.flagged[row][col]) {
                            coveredTiles++;
                        }
                    }
                }
                
                // Win if all mines are flagged AND no tiles are left uncovered
                if (flaggedMines === this.mines && coveredTiles === 0) {
                    this.gameWon = true;
                    this.interactionMode = 'auto';
                    this.clearShowMinesIndicator();
                    this.stopTimer();
                    // Award 500 points per mine when winning
                    this.addScore(500 * this.mines);
                }
            }

            updateMineCounter() {
                const mineCounter = document.getElementById('mineCounter');
                if (mineCounter) {
                    if (this.showMinesActive) {
                        const flaggedCount = this.flagged.flat().filter(flag => flag).length;
                        const minesLeft = Math.max(0, this.mines - flaggedCount);
                        mineCounter.textContent = minesLeft.toString().padStart(3, '0');
                        mineCounter.classList.add('showing-mines');
                    } else {
                        mineCounter.textContent = this.availableFlags.toString().padStart(3, '0');
                        mineCounter.classList.remove('showing-mines');
                    }
                }
                this.setBuyFlagLabel();
            }

            updateScore() {
                document.getElementById('score').textContent = this.score.toString().padStart(5, '0');
            }

            addScore(points) {
                const multiplier = this.powersDisabledMode ? 2 : 1;
                const awarded = points * multiplier;
                this.score += awarded;
                this.totalScore += awarded;
                localStorage.setItem('ms_totalScore', String(this.totalScore));
                this.updateScore();
                this.updateTotalScore();
            }

            updateTotalScore() {
                document.getElementById('totalScore').textContent = this.totalScore.toString().padStart(5, '0');
                this.updateCheckpointButton();
                this.updateShowMinesButton();
            }

            updateGameStatus() {
                const statusElement = document.getElementById('gameStatus');
                if (statusElement && statusElement.dataset.showMines === '1') {
                    return;
                }
                if (this.gameWon) {
                    statusElement.textContent = 'ðŸŽ‰ You Win! ðŸŽ‰';
                    statusElement.className = 'game-status win';
                } else if (this.gameOver) {
                    statusElement.textContent = 'ðŸ’¥ Game Over! ðŸ’¥';
                    statusElement.className = 'game-status lose';
                } else {
                    statusElement.textContent = '';
                    statusElement.className = 'game-status';
                }
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    if (this.startTime) {
                        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                        document.getElementById('timer').textContent = 
                            Math.min(elapsed, 999).toString().padStart(3, '0');
                    }
                }, 100);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            newGame() {
                this.stopTimer();
                this.clearShowMinesIndicator();
                this.mineDensity = this.resolveMineDensity();
                this.mines = Math.max(1, Math.round(this.mineDensity * this.rows * this.cols));
                this.availableFlags = this.mines;
                this.gameOver = false;
                this.gameWon = false;
                this.startTime = null;
                this.bombsUsed = 0;
                this.mineRevealed = false;
                this.bombTargeting = false;
                this.mineDetectorActive = false;
                this.hintsUsed = 0;
                this.lostMineRow = null;
                this.lostMineCol = null;
                this.maxBombs = this.calculateMaxBombs();
                this.maxHints = this.calculateMaxHints();
                this.updateCostsForDimensions(this.rows, this.cols);
                this.checkpointState = null;
                this.updateCheckpointButton();
                this.initializeBoard();
                const detectorBtn = document.getElementById('mineDetectorBtn');
                if (detectorBtn) {
                    detectorBtn.disabled = this.powersDisabledMode;
                }
                this.setMineDetectorIdleLabel();
                this.interactionMode = 'auto';
                this.refreshPowerButtons();
                this.score = 0;
                this.render();
                this.syncSizeEditorDefaults();
            }

            // ===== Board size controls =====
            openSizeEditor() {
                const overlay = document.getElementById('sizeEditorModal');
                if (!overlay) return;
                this.syncSizeEditorDefaults();
                overlay.style.display = 'flex';
            }

            closeSizeEditor() {
                const overlay = document.getElementById('sizeEditorModal');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }

            handleSizeEditorInput(sourceId) {
                const rowsSlider = document.getElementById('rowsSlider');
                const colsSlider = document.getElementById('colsSlider');
                const rowsInput = document.getElementById('rowsInput');
                const colsInput = document.getElementById('colsInput');
                const densityInput = document.getElementById('densityInput');
                const densityDisplay = document.getElementById('densityDisplay');
                if (!rowsSlider || !colsSlider || !rowsInput || !colsInput || !densityInput) return;

                if (sourceId === 'rowsSlider') {
                    rowsInput.value = rowsSlider.value;
                } else if (sourceId === 'rowsInput') {
                    const value = this.clampNumber(rowsInput.value, 5, 100);
                    rowsInput.value = value;
                    rowsSlider.value = value;
                }

                if (sourceId === 'colsSlider') {
                    colsInput.value = colsSlider.value;
                } else if (sourceId === 'colsInput') {
                    const value = this.clampNumber(colsInput.value, 5, 100);
                    colsInput.value = value;
                    colsSlider.value = value;
                }

                if (sourceId === 'densityInput' && densityDisplay) {
                    const percent = this.clampNumber(densityInput.value, 5, 50, false);
                    const rounded = Math.round(percent * 10) / 10;
                    densityInput.value = String(rounded);
                    const formatted = this.formatPercent(rounded, 1);
                    densityDisplay.textContent = densityInput.disabled ? `${formatted}% (preset)` : `${formatted}%`;
                }

                this.updateSizeEditorSummary();
            }

            updateSizeEditorSummary() {
                const rows = this.clampNumber(document.getElementById('rowsInput')?.value ?? this.rows, 5, 100);
                const cols = this.clampNumber(document.getElementById('colsInput')?.value ?? this.cols, 5, 100);
                const densitySlider = document.getElementById('densityInput');
                const summary = document.getElementById('sizeEditorSummary');
                if (!densitySlider || !summary) return;
                const densityPercent = this.clampNumber(densitySlider.value, 5, 50, false);
                const densityLabel = this.formatPercent(densityPercent, 1);
                const area = rows * cols;
                const mines = Math.max(1, Math.round((densityPercent / 100) * area));
                const bombs = this.calculateMaxBombsForDimensions(rows, cols);
                const bombLabel = bombs === 0 ? 'Bombs off' : `${bombs} bombs`;
                const hints = this.calculateMaxHintsForDimensions(rows, cols);
                const hintLabel = hints === 0 ? 'Hints off' : `${hints} hints`;
                summary.textContent = `${rows} Ã— ${cols} â€¢ ${area.toLocaleString()} cells â€¢ ${densityLabel}% density â€¢ ${mines.toLocaleString()} mines â€¢ ${bombLabel} â€¢ ${hintLabel}`;
            }

            applySizeEditor() {
                const rowsValue = this.clampNumber(document.getElementById('rowsInput')?.value ?? this.rows, 5, 100);
                const colsValue = this.clampNumber(document.getElementById('colsInput')?.value ?? this.cols, 5, 100);
                const densitySlider = document.getElementById('densityInput');
                if (!densitySlider) return;
                const densityPercent = this.clampNumber(densitySlider.value, 5, 50, false);
                this.rows = rowsValue;
                this.cols = colsValue;
                if (this.difficultyKey === 'custom') {
                    this.mineDensity = densityPercent / 100;
                    this.mineDensityRange = null;
                }
                this.closeSizeEditor();
                this.newGame();
            }

            syncSizeEditorDefaults() {
                const rowsSlider = document.getElementById('rowsSlider');
                const colsSlider = document.getElementById('colsSlider');
                const rowsInput = document.getElementById('rowsInput');
                const colsInput = document.getElementById('colsInput');
                const densityInput = document.getElementById('densityInput');
                const densityDisplay = document.getElementById('densityDisplay');
                if (rowsSlider) rowsSlider.value = String(this.rows);
                if (colsSlider) colsSlider.value = String(this.cols);
                if (rowsInput) rowsInput.value = String(this.rows);
                if (colsInput) colsInput.value = String(this.cols);
                if (densityInput) {
                    const percent = this.mineDensity * 100;
                    const clamped = this.clampNumber(percent, 5, 50, false);
                    const rounded = Math.round(clamped * 10) / 10;
                    densityInput.value = String(rounded);
                    const isCustom = this.difficultyKey === 'custom';
                    densityInput.disabled = !isCustom;
                    if (densityDisplay) {
                        const formatted = this.formatPercent(rounded, 1);
                        densityDisplay.textContent = isCustom ? `${formatted}%` : `${formatted}% (preset)`;
                    }
                }
                this.updateSizeEditorSummary();
            }

            clampNumber(value, min, max, round = true) {
                const num = Number(value);
                if (Number.isNaN(num)) return min;
                const bounded = Math.max(min, Math.min(max, num));
                return round ? Math.round(bounded) : bounded;
            }

            formatPercent(value, decimals = 1) {
                const factor = Math.pow(10, decimals);
                const rounded = Math.round(value * factor) / factor;
                const text = rounded.toFixed(decimals).replace(/\.?0+$/, '');
                return text;
            }

            updateDifficultyOptionLabels() {
                const select = document.getElementById('difficultySelect');
                if (!select) return;
                Array.from(select.options).forEach(option => {
                    if (option.value === 'custom') {
                        option.textContent = 'Custom';
                        return;
                    }
                    const profile = this.difficultyProfiles[option.value];
                    if (!profile) return;
                    if (profile.densityRange) {
                        const [min, max] = profile.densityRange;
                        const minLabel = this.formatPercent(min * 100, 1);
                        const maxLabel = this.formatPercent(max * 100, 1);
                        option.textContent = `${profile.label} (${minLabel}%-${maxLabel}%)`;
                    } else if (profile.density != null) {
                        const percentLabel = this.formatPercent(profile.density * 100, 1);
                        option.textContent = `${profile.label} (${percentLabel}%)`;
                    }
                });
            }


            cloneMatrix(matrix) {
                return matrix.map(row => row.slice());
            }

            captureCheckpointState() {
                const timerEl = document.getElementById('timer');
                return {
                    rows: this.rows,
                    cols: this.cols,
                    mines: this.mines,
                    mineDensity: this.mineDensity,
                    mineDensityRange: this.mineDensityRange ? [...this.mineDensityRange] : null,
                    difficultyKey: this.difficultyKey,
                    board: this.cloneMatrix(this.board),
                    revealed: this.cloneMatrix(this.revealed),
                    flagged: this.cloneMatrix(this.flagged),
                    availableFlags: this.availableFlags,
                    score: this.score,
                    totalScore: this.totalScore,
                    bombsUsed: this.bombsUsed,
                    maxBombs: this.maxBombs,
                    hintsUsed: this.hintsUsed,
                    powersDisabledMode: this.powersDisabledMode,
                    interactionMode: this.interactionMode,
                    elapsedTime: this.startTime ? Date.now() - this.startTime : null,
                    timerDisplay: timerEl ? timerEl.textContent : '000'
                };
            }

            restoreCheckpointState() {
                if (!this.checkpointState) return;
                this.clearShowMinesIndicator(false);
                const state = this.checkpointState;
                this.stopTimer();
                this.rows = state.rows;
                this.cols = state.cols;
                this.mines = state.mines;
                this.mineDensity = state.mineDensity;
                this.mineDensityRange = state.mineDensityRange ? [...state.mineDensityRange] : null;
                this.difficultyKey = state.difficultyKey || this.difficultyKey;
                const difficultySelect = document.getElementById('difficultySelect');
                if (difficultySelect && state.difficultyKey) {
                    difficultySelect.value = state.difficultyKey;
                }
                this.board = this.cloneMatrix(state.board);
                this.revealed = this.cloneMatrix(state.revealed);
                this.flagged = this.cloneMatrix(state.flagged);
                this.availableFlags = state.availableFlags;
                this.score = state.score;
                this.totalScore = state.totalScore;
                this.bombsUsed = state.bombsUsed;
                this.maxBombs = state.maxBombs;
                this.hintsUsed = state.hintsUsed;
                this.powersDisabledMode = state.powersDisabledMode;
                this.interactionMode = state.interactionMode || 'auto';
                this.gameOver = false;
                this.gameWon = false;
                this.mineRevealed = false;
                this.bombTargeting = false;
                this.mineDetectorActive = false;
                this.lostMineRow = null;
                this.lostMineCol = null;
                this.startTime = state.elapsedTime != null ? Date.now() - state.elapsedTime : null;
                localStorage.setItem('ms_totalScore', String(this.totalScore));
                this.render();
                this.syncSizeEditorDefaults();
                const powersBtn = document.getElementById('powersToggleBtn');
                if (powersBtn) powersBtn.textContent = this.powersDisabledMode ? 'Powers: Off' : 'Powers: On';
                if (this.startTime) {
                    this.startTimer();
                } else {
                    const timerEl = document.getElementById('timer');
                    if (timerEl) timerEl.textContent = state.timerDisplay || '000';
                }
                const timerEl = document.getElementById('timer');
                if (timerEl && state.timerDisplay) timerEl.textContent = state.timerDisplay;
                this.refreshPowerButtons();
                this.updateCheckpointButton();
            }

            checkpointFunction() {
                this.clearShowMinesIndicator();
                const cost = this.checkpointCost;
                if (this.gameOver) {
                    if (!this.checkpointState) return;
                    this.restoreCheckpointState();
                    return;
                }
                if (this.gameWon || this.powersDisabledMode) return;
                if (this.totalScore < cost) return;
                this.totalScore -= cost;
                if (this.totalScore < 0) this.totalScore = 0;
                localStorage.setItem('ms_totalScore', String(this.totalScore));
                this.updateTotalScore();
                this.checkpointState = this.captureCheckpointState();
                this.updateCheckpointButton();
            }

            updateCheckpointButton() {
                const btn = document.getElementById('checkpointBtn');
                if (!btn) return;
                const cost = this.checkpointCost;
                const hasCheckpoint = !!this.checkpointState;
                btn.classList.remove('active-mode');
                if (this.gameOver && hasCheckpoint) {
                    btn.textContent = 'Load Checkpoint';
                    btn.disabled = false;
                    return;
                }
                if (this.gameOver || this.gameWon) {
                    btn.textContent = `Checkpoint (${cost})`;
                    btn.disabled = true;
                    return;
                }
                const label = hasCheckpoint ? `Checkpoint Ready (${cost})` : `Checkpoint (${cost})`;
                btn.textContent = label;
                const disable = this.powersDisabledMode || this.totalScore < cost;
                btn.disabled = disable;
            }

            updateShowMinesButton() {
                const btn = document.getElementById('showMinesBtn');
                if (!btn) return;
                if (this.showMinesActive) {
                    btn.textContent = 'Showing Mines...';
                } else {
                    btn.textContent = `Show Mines Left (${this.showMinesCost})`;
                }
                const disable = this.powersDisabledMode || this.gameOver || this.gameWon || this.totalScore < this.showMinesCost || this.showMinesActive;
                btn.disabled = disable;
            }

            clearShowMinesIndicator(updateButton = true) {
                if (this.showMinesTimeout) {
                    clearTimeout(this.showMinesTimeout);
                    this.showMinesTimeout = null;
                }
                const statusElement = document.getElementById('gameStatus');
                if (statusElement && statusElement.dataset.showMines === '1') {
                    delete statusElement.dataset.showMines;
                    statusElement.textContent = '';
                    statusElement.className = 'game-status';
                }
                const mineCounter = document.getElementById('mineCounter');
                if (mineCounter) {
                    mineCounter.classList.remove('showing-mines');
                }
                this.showMinesActive = false;
                this.updateMineCounter();
                if (updateButton) {
                    this.updateShowMinesButton();
                }
                this.updateGameStatus();
            }

            showMinesLeftFunction() {
                if (this.gameOver || this.gameWon) {
                    this.updateShowMinesButton();
                    return;
                }
                if (this.powersDisabledMode) return;
                const cost = this.showMinesCost;
                if (this.totalScore < cost) return;
                if (this.showMinesActive) return;
                this.totalScore -= cost;
                if (this.totalScore < 0) this.totalScore = 0;
                localStorage.setItem('ms_totalScore', String(this.totalScore));
                this.updateTotalScore();
                const statusElement = document.getElementById('gameStatus');
                const mineCounter = document.getElementById('mineCounter');
                const flaggedCount = this.flagged.flat().filter(flag => flag).length;
                const minesLeft = Math.max(0, this.mines - flaggedCount);
                if (statusElement) {
                    statusElement.dataset.showMines = '1';
                    statusElement.textContent = `Mines left: ${minesLeft}`;
                    statusElement.className = 'game-status';
                }
                this.showMinesActive = true;
                this.updateShowMinesButton();
                this.updateMineCounter();
                this.showMinesTimeout = setTimeout(() => {
                    this.showMinesTimeout = null;
                    this.clearShowMinesIndicator();
                }, 5000);
            }

            calculateMaxBombsForDimensions(rows, cols) {
                const minDimension = Math.min(rows, cols);
                if (minDimension < 15) return 0;
                const area = rows * cols;
                const scaled = Math.round((area / this.baseArea) * 5);
                return Math.max(1, Math.min(12, scaled));
            }

            calculateMaxBombs() {
                return this.calculateMaxBombsForDimensions(this.rows, this.cols);
            }

            calculateMaxHintsForDimensions(rows, cols) {
                const minDimension = Math.min(rows, cols);
                if (minDimension <= 15) return 0;
                const area = rows * cols;
                const ratio = area / this.baseArea;
                const scaled = Math.round(this.baseHintCount * ratio);
                return Math.max(1, Math.min(15, scaled));
            }

            calculateMaxHints() {
                return this.calculateMaxHintsForDimensions(this.rows, this.cols);
            }

            calculatePriceMultiplierForDimensions(rows, cols) {
                const area = rows * cols;
                if (area <= 0) return 1;
                const multiplier = this.baseArea / area;
                return Math.max(0.5, Math.min(2, multiplier));
            }

            adjustCost(baseCost, multiplier) {
                const raw = baseCost * multiplier;
                return Math.max(10, Math.round(raw / 10) * 10);
            }

            updateCostsForDimensions(rows, cols) {
                const multiplier = this.calculatePriceMultiplierForDimensions(rows, cols);
                this.priceMultiplier = multiplier;
                this.mineDetectorCost = this.adjustCost(this.baseCosts.mineDetector, multiplier);
                this.buyFlagCost = this.adjustCost(this.baseCosts.buyFlag, multiplier);
                this.revealMineCost = this.adjustCost(this.baseCosts.revealMine, multiplier);
                this.showMinesCost = this.adjustCost(this.baseCosts.showMines, multiplier);
            }

            getMineDetectorLabel() {
                return `Mine Detector (${this.mineDetectorCost})`;
            }

            setMineDetectorIdleLabel() {
                const btn = document.getElementById('mineDetectorBtn');
                if (!btn || this.mineDetectorActive) return;
                btn.textContent = this.getMineDetectorLabel();
                btn.style.backgroundColor = '#c0c0c0';
            }

            getBuyFlagLabel() {
                return `Buy Flag (${this.buyFlagCost})`;
            }

            setBuyFlagLabel() {
                const btn = document.getElementById('buyFlagBtn');
                if (!btn) return;
                const flags = Math.max(0, this.availableFlags);
                btn.textContent = `${this.getBuyFlagLabel()} - ${flags}`;
            }

            getRevealMineLabel() {
                return `Reveal Mine (-${this.revealMineCost})`;
            }

            setRevealMineLabel() {
                const btn = document.getElementById('revealMineBtn');
                if (!btn) return;
                btn.textContent = this.getRevealMineLabel();
            }

            updateCostLabels() {
                this.setMineDetectorIdleLabel();
                this.setBuyFlagLabel();
                this.setRevealMineLabel();
                this.updateCheckpointButton();
                this.updateShowMinesButton();
            }

            updateHintButton() {
                const hintBtn = document.getElementById('hintBtn');
                if (!hintBtn) return;
                const disable = this.powersDisabledMode || this.gameOver || this.gameWon || this.maxHints === 0 || this.hintsUsed >= this.maxHints;
                hintBtn.disabled = disable;
                if (this.maxHints === 0) {
                    hintBtn.textContent = 'Hint (Disabled)';
                } else {
                    const remaining = Math.max(0, this.maxHints - this.hintsUsed);
                    hintBtn.textContent = `Hint (${remaining}/${this.maxHints})`;
                }
            }

            toggleInteractionMode(mode) {
                if (this.gameOver || this.gameWon) return;
                const nextMode = this.interactionMode === mode ? 'auto' : mode;
                this.interactionMode = nextMode;
                if (this.holdTimer) {
                    clearTimeout(this.holdTimer);
                    this.holdTimer = null;
                }
                this.updateInteractionModeUi();
            }

            updateInteractionModeUi() {
                const revealModeBtn = document.getElementById('interactionRevealBtn');
                const flagModeBtn = document.getElementById('interactionFlagBtn');
                const disabled = this.gameOver || this.gameWon;
                if (revealModeBtn) {
                    const active = this.interactionMode === 'reveal';
                    revealModeBtn.classList.toggle('active-mode', active);
                    revealModeBtn.textContent = active ? 'Reveal Mode (Active)' : 'Reveal Mode';
                    revealModeBtn.disabled = disabled;
                }
                if (flagModeBtn) {
                    const active = this.interactionMode === 'flag';
                    flagModeBtn.classList.toggle('active-mode', active);
                    flagModeBtn.textContent = active ? 'Flag Mode (Active)' : 'Flag Mode';
                    flagModeBtn.disabled = disabled;
                }
            }

            updateBombUi() {
                const bombBtn = document.getElementById('bombBtn');
                if (!bombBtn) return;
                if (this.bombTargeting) {
                    bombBtn.disabled = false;
                    bombBtn.textContent = 'Click to Drop Bomb';
                    bombBtn.style.backgroundColor = '#ff6b6b';
                    return;
                }
                const noBombs = this.maxBombs === 0;
                const finished = this.bombsUsed >= this.maxBombs;
                const disabled = this.gameOver || this.gameWon || noBombs;
                bombBtn.disabled = disabled || finished;
                if (disabled) {
                    bombBtn.textContent = 'Bomb (5x5) - Disabled';
                } else {
                    const remaining = Math.max(0, this.maxBombs - this.bombsUsed);
                    bombBtn.textContent = `Bomb (5x5) - ${remaining}`;
                }
                bombBtn.style.backgroundColor = '#c0c0c0';
            }

            refreshPowerButtons() {
                const disable = this.powersDisabledMode;
                const revealMineBtn = document.getElementById('revealMineBtn');
                const mineDetectorBtn = document.getElementById('mineDetectorBtn');
                const buyFlagBtn = document.getElementById('buyFlagBtn');
                if (revealMineBtn) revealMineBtn.disabled = disable || this.gameOver || this.gameWon;
                if (mineDetectorBtn) mineDetectorBtn.disabled = disable || this.gameOver || this.gameWon;
                if (buyFlagBtn) buyFlagBtn.disabled = disable || this.gameOver || this.gameWon;
                this.updateHintButton();
                this.updateInteractionModeUi();
                this.updateCheckpointButton();
                this.updateShowMinesButton();
            }

            resolveMineDensity() {
                if (this.difficultyKey === 'custom') {
                    return Math.max(0.05, Math.min(0.5, this.mineDensity));
                }
                const profile = this.difficultyProfiles[this.difficultyKey];
                if (!profile) {
                    return Math.max(0.05, Math.min(0.5, this.mineDensity));
                }
                if (profile.densityRange) {
                    this.mineDensityRange = profile.densityRange;
                    const [min, max] = profile.densityRange;
                    const density = min + Math.random() * (max - min);
                    return Math.max(0.05, Math.min(0.5, density));
                }
                this.mineDensityRange = null;
                return Math.max(0.05, Math.min(0.5, profile.density));
            }

            // ===== Powers Disabled Mode =====
            togglePowers() {
                this.powersDisabledMode = !this.powersDisabledMode;
                const btn = document.getElementById('powersToggleBtn');
                btn.textContent = this.powersDisabledMode ? 'Powers: Off' : 'Powers: On';
                this.refreshPowerButtons();
            }

            // ===== Simple Mini Game =====
            openMiniGame() {
                const overlay = document.getElementById('miniGameModal');
                overlay.style.display = 'flex';
                this.setupMiniGameShell();
            }

            closeMiniGame() {
                const overlay = document.getElementById('miniGameModal');
                overlay.style.display = 'none';
                this.teardownMiniGame();
            }

            setupMiniGameShell() {
                const target = document.getElementById('target');
                const area = document.getElementById('targetArea');
                const info = document.getElementById('miniGameInfo');
                const startBtn = document.getElementById('startMiniGameBtn');
                const closeBtn = document.getElementById('closeMiniGameBtn');
                const select = document.getElementById('miniGameSelect');
                const desc = document.getElementById('miniGameDesc');
                const reaction = document.getElementById('reactionLight');
                const reactionText = document.getElementById('reactionText');
                const simonGrid = document.getElementById('simonGrid');
                const mathWrap = document.getElementById('mathWrap');
                const mathQuestion = document.getElementById('mathQuestion');
                const mathA = document.getElementById('mathA');
                const mathB = document.getElementById('mathB');
                const mathC = document.getElementById('mathC');
                const coinWrap = document.getElementById('coinWrap');
                const coinStatus = document.getElementById('coinStatus');
                const headsBtn = document.getElementById('headsBtn');
                const tailsBtn = document.getElementById('tailsBtn');
                
                this.miniGame = { hits: 0, goal: 10, timeLeft: 15, interval: null, mover: null };
                info.textContent = `Choose a minigame to begin.`;
                reaction.style.display = 'none';
                simonGrid.style.display = 'none';
                target.style.display = 'block';
                target.textContent = 'ðŸ’£';
                desc.textContent = 'Tap the moving target 10 times in 15 seconds to win 5,000 points.';
                
                const clearBindings = () => {
                    // Stop current round and remove transient handlers so we can swap games
                    this.miniGameRunning = false;
                    if (this.miniGame && this.miniGame.interval) { clearInterval(this.miniGame.interval); this.miniGame.interval = null; }
                    if (this.miniGame && this.miniGame._spawner) { clearInterval(this.miniGame._spawner); this.miniGame._spawner = null; }
                    target.onclick = null;
                    target.ontouchstart = null;
                    area.onclick = null;
                    area.ontouchstart = null;
                    Array.from(document.querySelectorAll('#simonGrid .simon')).forEach(el => { el.onclick = null; el.ontouchstart = null; });
                    // Remove any transient mole targets
                    Array.from(area.querySelectorAll('.target'))
                        .filter(el => el.id !== 'target')
                        .forEach(el => el.remove());
                    // Reset hold UI
                    const barWrap = document.getElementById('holdBarWrap');
                    const bar = document.getElementById('holdBar');
                    if (barWrap) barWrap.style.display = 'none';
                    if (bar) bar.style.width = '0%';
                    if (coinWrap) coinWrap.style.display = 'none';
                    if (coinStatus) coinStatus.textContent = 'Pick Heads or Tails';
                    if (headsBtn) headsBtn.onclick = null;
                    if (headsBtn) headsBtn.ontouchstart = null;
                    if (tailsBtn) tailsBtn.onclick = null;
                    if (tailsBtn) tailsBtn.ontouchstart = null;
                };
                
                const syncUIForSelection = () => {
                    clearBindings();
                    const v = select.value;
                    reaction.style.display = 'none';
                    simonGrid.style.display = 'none';
                    target.style.display = 'none';
                    if (v === 'tap') {
                        desc.textContent = 'Tap the moving target 10 times in 15 seconds to win 5,000 points.';
                        target.style.display = 'block';
                        info.textContent = 'Hits: 0/10 â€¢ Time: 15s';
                        mathWrap.style.display = 'none';
                    } else if (v === 'react') {
                        desc.textContent = 'Tap when the screen turns green. Three rounds. Be fast!';
                        reaction.style.display = 'flex';
                        reactionText.textContent = 'Wait for green...';
                        info.textContent = 'Best: â€” ms';
                        mathWrap.style.display = 'none';
                    } else if (v === 'simon') {
                        desc.textContent = 'Repeat the flashing sequence. Reach 6 steps to win!';
                        simonGrid.style.display = 'grid';
                        info.textContent = 'Round: 1 / 6';
                        mathWrap.style.display = 'none';
                    } else if (v === 'frenzy') {
                        desc.textContent = 'Score as many hits as you can in 20s. Each hit = 50 pts.';
                        target.style.display = 'block';
                        info.textContent = 'Hits: 0 â€¢ Time: 20s';
                        mathWrap.style.display = 'none';
                    } else if (v === 'numbers') {
                        desc.textContent = 'Tap numbers 1â†’10 in order as fast as possible. Win for finishing (smaller bonus).';
                        target.style.display = 'block';
                        info.textContent = 'Next: 1';
                        mathWrap.style.display = 'none';
                    } else if (v === 'moles') {
                        desc.textContent = 'Whack the mines that pop up. 20s round; each hit = 75 pts.';
                        target.style.display = 'none';
                        info.textContent = 'Hits: 0 â€¢ Time: 20s';
                        mathWrap.style.display = 'none';
                    } else if (v === 'hold') {
                        desc.textContent = 'Press and hold to fill the bar to 100% before time runs out!';
                        target.style.display = 'none';
                        info.textContent = 'Hold to charge';
                        document.getElementById('holdBarWrap').style.display = 'none';
                        mathWrap.style.display = 'none';
                    } else if (v === 'math') {
                        // Only show gray buttons once the game starts
                        desc.textContent = 'Answer as many questions as you can in 20s. Tap Start to begin!';
                        info.textContent = 'Ready';
                        target.style.display = 'none';
                        reaction.style.display = 'none';
                        simonGrid.style.display = 'none';
                        mathWrap.style.display = 'none';
                    } else if (v === 'coin') {
                        desc.textContent = 'Coin Flip: 10 rounds. +150 for correct guess.';
                        info.textContent = 'Ready';
                        target.style.display = 'none';
                        reaction.style.display = 'none';
                        simonGrid.style.display = 'none';
                        mathWrap.style.display = 'none';
                        if (coinWrap) coinWrap.style.display = 'none';
                        if (coinStatus) coinStatus.textContent = 'Pick Heads or Tails';
                    }
                };
                select.onchange = syncUIForSelection;
                syncUIForSelection();
                
                const moveTarget = () => {
                    const maxX = area.clientWidth - 36;
                    const maxY = area.clientHeight - 36;
                    const x = Math.floor(Math.random() * (maxX + 1));
                    const y = Math.floor(Math.random() * (maxY + 1));
                    target.style.transform = `translate(${x}px, ${y}px)`;
                };
                
                const onHit = (e) => {
                    e.preventDefault();
                    if (!this.miniGameRunning || select.value !== 'tap') return;
                    this.miniGame.hits++;
                    info.textContent = `Hits: ${this.miniGame.hits}/10 â€¢ Time: ${this.miniGame.timeLeft}s`;
                    moveTarget();
                    if (this.miniGame.hits >= this.miniGame.goal) this.finishMiniGame(true);
                };
                
                target.addEventListener('click', onHit);
                target.addEventListener('touchstart', onHit, { passive: false });
                
                // Reaction game state
                const startReaction = () => {
                    this.miniGameRunning = true;
                    let clickedTooEarly = false;
                    reactionText.textContent = 'Wait for green...';
                    reaction.style.background = '#8e44ad';
                    const delay = 800 + Math.floor(Math.random() * 2200);
                    let startTs = 0;
                    const onAreaTap = () => {
                        if (!this.miniGameRunning) return;
                        if (startTs === 0) { clickedTooEarly = true; this.finishMiniGame(false); }
                        else { const rt = Math.floor(performance.now() - startTs); this._reactionResults.push(rt); this._nextReactionRound(); }
                    };
                    area.onclick = onAreaTap;
                    area.ontouchstart = (e)=>{ e.preventDefault(); onAreaTap(); };
                    setTimeout(() => {
                        if (!this.miniGameRunning) return;
                        reaction.style.background = '#2ecc71';
                        reactionText.textContent = 'Tap!';
                        startTs = performance.now();
                    }, delay);
                };
                this._reactionResults = [];
                this._nextReactionRound = () => {
                    if (this._reactionResults.length >= 3) {
                        const best = Math.min(...this._reactionResults);
                        info.textContent = `Best: ${best} ms`;
                        // Win if best under 300ms
                        if (best <= 300) this.finishMiniGame(true); else this.finishMiniGame(false);
                        return;
                    }
                    startReaction();
                };

                // Simon game state
                const simonTiles = Array.from(simonGrid.querySelectorAll('.simon'));
                const flash = async (idx) => {
                    const el = simonTiles[idx];
                    const old = el.style.filter;
                    el.style.filter = 'brightness(2)';
                    await new Promise(r=>setTimeout(r, 280));
                    el.style.filter = old || 'brightness(1)';
                    await new Promise(r=>setTimeout(r, 120));
                };
                const playSequence = async (seq) => {
                    for (const i of seq) { await flash(i); }
                };
                const resetSimon = () => {
                    this._simonSeq = [Math.floor(Math.random()*4)];
                    this._simonPos = 0;
                    this._simonRound = 1;
                    info.textContent = 'Round: 1 / 6';
                };
                const startSimon = async () => {
                    this.miniGameRunning = true;
                    await playSequence(this._simonSeq);
                };
                const bindSimonHandlers = () => {
                    simonTiles.forEach(tile => {
                        const onTap = async () => {
                            if (!this.miniGameRunning || select.value !== 'simon') return;
                            const idx = Number(tile.dataset.idx);
                            if (idx === this._simonSeq[this._simonPos]) {
                                this._simonPos++;
                                if (this._simonPos >= this._simonSeq.length) {
                                    // next round
                                    this._simonRound++;
                                    info.textContent = `Round: ${this._simonRound} / 6`;
                                    if (this._simonRound > 6) { this.finishMiniGame(true); return; }
                                    this._simonSeq.push(Math.floor(Math.random()*4));
                                    this._simonPos = 0;
                                    await new Promise(r=>setTimeout(r, 400));
                                    await playSequence(this._simonSeq);
                                }
                            } else {
                                this.finishMiniGame(false);
                            }
                        };
                        tile.onclick = onTap;
                        tile.ontouchstart = (e)=>{ e.preventDefault(); onTap(); };
                    });
                };
                // initial bind
                bindSimonHandlers();

                startBtn.onclick = async () => {
                    const mode = select.value;
                    // If a game was running, end it as a loss (no points) before starting new one
                    if (this.miniGameRunning) {
                        this.finishMiniGame(false, { losePoints: 0 });
                    }
                    clearBindings();
                    this.miniGameRunning = true;
                    if (mode === 'tap') {
                        this.miniGame.hits = 0;
                        this.miniGame.timeLeft = 15;
                        moveTarget();
                        if (this.miniGame.interval) clearInterval(this.miniGame.interval);
                        this.miniGame.interval = setInterval(() => {
                            this.miniGame.timeLeft--;
                            info.textContent = `Hits: ${this.miniGame.hits}/10 â€¢ Time: ${this.miniGame.timeLeft}s`;
                            moveTarget();
                            if (this.miniGame.timeLeft <= 0) this.finishMiniGame(false);
                        }, 1000);
                    } else if (mode === 'react') {
                        this._reactionResults = [];
                        this._nextReactionRound();
                    } else if (mode === 'simon') {
                        resetSimon();
                        bindSimonHandlers();
                        await startSimon();
                    } else if (mode === 'frenzy') {
                        // 20s timed, each hit worth 500
                        this.miniGame.hits = 0;
                        this.miniGame.timeLeft = 20;
                        target.textContent = 'ðŸŽ¯';
                        const onFrenzyTap = (e) => {
                            e.preventDefault();
                            if (!this.miniGameRunning) return;
                            this.miniGame.hits++;
                            info.textContent = `Hits: ${this.miniGame.hits} â€¢ Time: ${this.miniGame.timeLeft}s`;
                            moveTarget();
                        };
                        target.onclick = onFrenzyTap;
                        target.ontouchstart = (e)=>{ e.preventDefault(); onFrenzyTap(e); };
                        moveTarget();
                        if (this.miniGame.interval) clearInterval(this.miniGame.interval);
                        this.miniGame.interval = setInterval(() => {
                            this.miniGame.timeLeft--;
                            info.textContent = `Hits: ${this.miniGame.hits} â€¢ Time: ${this.miniGame.timeLeft}s`;
                            moveTarget();
                            if (this.miniGame.timeLeft <= 0) {
                                const pts = this.miniGame.hits * 50;
                                this.finishMiniGame(true, { winPoints: pts });
                            }
                        }, 1000);
                    } else if (mode === 'numbers') {
                        // 1 to 10 ordered taps
                        let next = 1;
                        target.textContent = String(next);
                        const numMove = () => moveTarget();
                        const onNumTap = (e) => {
                            e.preventDefault();
                            if (!this.miniGameRunning) return;
                            const val = Number(target.textContent);
                            if (val === next) {
                                next++;
                                if (next > 10) {
                                    // reward based on speed: remaining seconds * 200 + 2000 base
                                    const base = 2000;
                                    const speed = Math.max(0, (this.miniGame?.timeLeft || 0)) * 200;
                                    this.finishMiniGame(true, { winPoints: base + speed });
                                    return;
                                }
                                target.textContent = String(next);
                                info.textContent = `Next: ${next}`;
                                numMove();
                            } else {
                                this.finishMiniGame(false, { losePoints: 1000 });
                            }
                        };
                        target.onclick = onNumTap;
                        target.ontouchstart = (e)=>{ e.preventDefault(); onNumTap(e); };
                        this.miniGame.timeLeft = 25; // allow 25s
                        info.textContent = 'Next: 1';
                        numMove();
                        if (this.miniGame.interval) clearInterval(this.miniGame.interval);
                        this.miniGame.interval = setInterval(() => {
                            this.miniGame.timeLeft--;
                            if (this.miniGame.timeLeft <= 0) this.finishMiniGame(false, { losePoints: 0 });
                        }, 1000);
                    } else if (mode === 'moles') {
                        // Whack-a-Mine: spawn tap targets periodically
                        this.miniGame.hits = 0;
                        this.miniGame.timeLeft = 20;
                        const spawn = () => {
                            if (!this.miniGameRunning) return;
                            const mole = document.createElement('div');
                            mole.className = 'target';
                            mole.textContent = 'ðŸ’¥';
                            const maxX = area.clientWidth - 36;
                            const maxY = area.clientHeight - 36;
                            const x = Math.floor(Math.random() * (maxX + 1));
                            const y = Math.floor(Math.random() * (maxY + 1));
                            mole.style.transform = `translate(${x}px, ${y}px)`;
                            const onHit = (e) => {
                                e.preventDefault();
                                if (!this.miniGameRunning) return;
                                this.miniGame.hits++;
                                info.textContent = `Hits: ${this.miniGame.hits} â€¢ Time: ${this.miniGame.timeLeft}s`;
                                mole.remove();
                            };
                            mole.onclick = onHit;
                            mole.ontouchstart = (e)=>{ e.preventDefault(); onHit(e); };
                            area.appendChild(mole);
                            setTimeout(() => mole.remove(), 600);
                        };
                        // spawn cadence
                        const spawner = setInterval(spawn, 500);
                        this.miniGame._spawner = spawner;
                        if (this.miniGame.interval) clearInterval(this.miniGame.interval);
                        this.miniGame.interval = setInterval(() => {
                            this.miniGame.timeLeft--;
                            info.textContent = `Hits: ${this.miniGame.hits} â€¢ Time: ${this.miniGame.timeLeft}s`;
                            if (this.miniGame.timeLeft <= 0) {
                                clearInterval(spawner);
                                const pts = this.miniGame.hits * 75;
                                this.finishMiniGame(true, { winPoints: pts });
                            }
                        }, 1000);
                    } else if (mode === 'hold') {
                        // Hold Challenge: hold down to fill progress bar
                        const barWrap = document.getElementById('holdBarWrap');
                        const bar = document.getElementById('holdBar');
                        barWrap.style.display = 'block';
                        bar.style.width = '0%';
                        this.miniGame.timeLeft = 2;
                        let progress = 0; // 0..100
                        let holding = false;
                        const gainRate = 80; // percent per second while holding
                        const decayRate = 40; // percent per second while not holding
                        const step = 50; // ms
                        const tick = () => {
                            if (!this.miniGameRunning) return;
                            const delta = holding ? gainRate : -decayRate;
                            progress = Math.max(0, Math.min(100, progress + (delta * step) / 1000));
                            bar.style.width = `${progress}%`;
                            if (progress >= 100) {
                                this.finishMiniGame(true, { winPoints: 1500 });
                            } else {
                                setTimeout(tick, step);
                            }
                        };
                        const setHold = (v) => { holding = v; };
                        area.onmousedown = ()=>setHold(true);
                        area.onmouseup = ()=>setHold(false);
                        area.onmouseleave = ()=>setHold(false);
                        area.ontouchstart = (e)=>{ e.preventDefault(); setHold(true); };
                        area.ontouchend = ()=>setHold(false);
                        tick();
                        if (this.miniGame.interval) clearInterval(this.miniGame.interval);
                        this.miniGame.interval = setInterval(() => {
                            this.miniGame.timeLeft--;
                            info.textContent = `Time: ${this.miniGame.timeLeft}s`;
                            if (this.miniGame.timeLeft <= 0 && this.miniGameRunning) this.finishMiniGame(false, { losePoints: Math.floor(progress * 5) });
                        }, 1000);
                    } else if (mode === 'math') {
                        // Show math UI only after Start
                        mathWrap.style.display = 'flex';
                        const genQ = () => {
                            const a = Math.floor(Math.random()*10)+1;
                            const b = Math.floor(Math.random()*10)+1;
                            const ops = ['+','-','Ã—'];
                            const op = ops[Math.floor(Math.random()*ops.length)];
                            let answer = 0;
                            if (op === '+') answer = a + b; else if (op === '-') answer = a - b; else answer = a * b;
                            const choices = [answer, answer + (Math.floor(Math.random()*5)+1), answer - (Math.floor(Math.random()*5)+1)];
                            // shuffle
                            for (let i = choices.length - 1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [choices[i], choices[j]] = [choices[j], choices[i]]; }
                            return { text: `${a} ${op} ${b} = ?`, answer, choices };
                        };
                        let score = 0;
                        const ask = () => {
                            const q = genQ();
                            mathQuestion.textContent = q.text;
                            [mathA, mathB, mathC].forEach((btn, i)=>{ btn.textContent = String(q.choices[i]); btn.onclick = () => {
                                if (!this.miniGameRunning) return;
                                if (Number(btn.textContent) === q.answer) { score += 1; this.addScore(50); }
                                ask();
                            }; });
                        };
                        score = 0;
                        this.miniGame.timeLeft = 20;
                        info.textContent = 'Time: 20s â€¢ Correct: 0';
                        ask();
                        if (this.miniGame.interval) clearInterval(this.miniGame.interval);
                        this.miniGame.interval = setInterval(() => {
                            this.miniGame.timeLeft--;
                            info.textContent = `Time: ${this.miniGame.timeLeft}s â€¢ Correct: ${score}`;
                            if (this.miniGame.timeLeft <= 0) {
                                const pts = score * 100; // final bonus
                                this.finishMiniGame(true, { winPoints: pts });
                            }
                        }, 1000);
                    } else if (mode === 'coin') {
                        if (!coinWrap || !coinStatus || !headsBtn || !tailsBtn) return;
                        coinWrap.style.display = 'flex';
                        coinStatus.textContent = 'Pick Heads or Tails';
                        let round = 0;
                        let correct = 0;
                        const play = (guess) => {
                            if (!this.miniGameRunning || select.value !== 'coin') return;
                            const flip = Math.random() < 0.5 ? 'Heads' : 'Tails';
                            const win = (guess === flip);
                            if (win) { correct++; this.addScore(150); }
                            round++;
                            coinStatus.textContent = `Flip: ${flip} â€¢ Correct: ${correct} / ${round}`;
                            if (round >= 10) {
                                const bonus = correct * 50;
                                this.finishMiniGame(true, { winPoints: bonus });
                            }
                        };
                        const handleHeads = (e) => { if (e) e.preventDefault(); play('Heads'); };
                        const handleTails = (e) => { if (e) e.preventDefault(); play('Tails'); };
                        headsBtn.onclick = handleHeads;
                        tailsBtn.onclick = handleTails;
                        headsBtn.ontouchstart = handleHeads;
                        tailsBtn.ontouchstart = handleTails;
                    }
                };
                closeBtn.onclick = () => this.closeMiniGame();
                this._miniGameMove = moveTarget;
            }

            teardownMiniGame() {
                this.miniGameRunning = false;
                if (this.miniGame && this.miniGame.interval) clearInterval(this.miniGame.interval);
            }

            finishMiniGame(won, opts = {}) {
                this.miniGameRunning = false;
                if (this.miniGame && this.miniGame.interval) clearInterval(this.miniGame.interval);
                const info = document.getElementById('miniGameInfo');
                const winPoints = opts.winPoints != null ? opts.winPoints : 5000;
                // default lose points: use supplied losePoints else proportional to hits (reduced)
                const losePoints = opts.losePoints != null ? opts.losePoints : Math.floor((this.miniGame?.hits || 0) * 2);
                if (won) {
                    this.addScore(winPoints);
                    info.textContent = `You win! +${winPoints.toLocaleString()} points`;
                } else {
                    this.addScore(losePoints);
                    info.textContent = `Nice try! +${losePoints.toLocaleString()} points`;
                }
            }
        }

        // Initialize the game
        const game = new Minesweeper(40, 40, 325);
    </script>
</body>
</html>
